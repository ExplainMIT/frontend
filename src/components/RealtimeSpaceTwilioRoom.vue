<template>
  <div>
    <v-btn @click="shareScreen()">Share screen</v-btn>
    	<!-- <Carousel
        :paginationEnabled="false"
        :navigationEnabled="true"
        :perPageCustom="[[0, 1], [600, 2], [850, 3], [1100, 4], [1350, 5]]"
        class="video-row"
      > -->

        <!-- Local user profile -->
        <!-- <Slide class="video-col">
          <div class="video-container-wrapper">
            <div v-show="!isMinimizedView" id="local-media" class="video-container"/>
            <div class="display-bar">
              <div class="name-container">
                {{ user.firstName + " " + user.lastName }}
              </div>
              <div class="local-buttons-container">
                <v-btn @click="toggleMic()" x-small><v-icon small>{{isMicOn ? 'mdi-microphone': 'mdi-microphone-off'}}</v-icon></v-btn>
                <v-btn @click="toggleCamera()" x-small ><v-icon small>{{isCameraOn ? 'mdi-video': 'mdi-video-off'}}</v-icon></v-btn>
              </div>
            </div>
          </div>
        </Slide> -->

        <!-- <Slide class="video-col">
          <div class="video-container-wrapper" >
            <div :id="`remote-media-${participant.sessionID}`"  class="video-container"/>
            <div  v-show=" !isMinimizedView && participant.isCameraOn" :id="`remote-media-${participant.sessionID}`"  class="video-container"/>
            <v-icon v-show=" !isMinimizedView && !participant.isCameraOn" color="white" x-large style="width: 100%; height: 100%">mdi-video-off</v-icon>
            <div class="display-bar">
              <div class="name-container">
                {{ participant.firstName + " " + participant.lastName }}
              </div>
              <v-icon class="participant-mic">
                {{ participant.isMicOn ? 'mdi-microphone': 'mdi-microphone-off' }}
              </v-icon> 
            </div>
          </div>
        </Slide>
      </Carousel> -->
    <div id="remote-media-div">

    </div>
  </div>
</template>

<script>
/**
 * TODO: If user is on the wrong browser, display an error message to inform them to switch
 * 
 * @see screencapture https://www.twilio.com/docs/video/screen-capture-chrome
 * @see https://www.twilio.com/docs/video
 * @see API https://www.twilio.com/docs/video/tutorials/understanding-video-rooms-apis
 * 
 * A Track is a stream of bytes that contain the data generated by a multimedia source such as a microphone or a camera.
 * 
 * Correctness proof: 
 * 
 * Initial state: 
 *    - Local user publishes his/her tracks. 
 *    - Local user fetches other people's tracks. 
 *    - Therefore initial state is correct. 
 * 
 * Transition state: 
 *    - every new user will be detected with "onConnected"
 *    - for each new user, each of their tracks will be handled when they are published/unpublished 
 *    - every user who disconnect will be handled by "onDisconnected"
 *    
 * Therefore, all states will be correct. 
 */
import { Carousel, Slide } from 'vue-carousel';
import { connect, LocalVideoTrack } from "twilio-video";
import { twilioCreds } from "@/twiliocreds.js";
import { mapState } from "vuex";
import { getRandomId } from "@/helpers.js";

export default {
  props: {
    roomID: {
      type: String,
      required: true
    }
  },
  components: {
    Carousel,
		Slide
  },
  data () {
    return {
      twilioRoom: null
    };
  },
  computed: {
    ...mapState([
      "session",
      "user"
    ])
  },
  async created () {
    // connect to the Twilio room
    try {
      this.twilioRoom = await connect(this.getAccessToken(), { name: this.roomID, audio: true }); // video: { width: 640 }
      console.log("Successfully joined Twilio room =", this.twilioRoom);
      this.$root.$emit("show-snackbar", "Successfully connected to the voice chat.");
    } catch (error) {
      console.error(`Unable to connect to Room: ${error.message}`);
      this.$root.$emit("show-snackbar", "Failed to connect, error =", error.message);
    }

    // mute ourselves to prevent feedback echoes
    this.twilioRoom.localParticipant.audioTracks.forEach(publication => {
      publication.track.disable();
    });
    
    // handle existing participants
    this.twilioRoom.participants.forEach(participant => {
      this.listenToRemoteParticipant(participant);
    });

    // handle future participants
    this.twilioRoom.on(
      'participantConnected', 
      participant => this.listenToRemoteParticipant(participant)
    );
    
    // whenever people disconnect, remove their streams
    this.twilioRoom.on('participantDisconnected', participant => {
      // TODO: update the state
      console.log(`Participant disconnected: ${participant.identity}`);
    });
  },
  destroyed () {
    if (this.twilioRoom) {
      console.log("destroyed(), diconnecting from TwilioRoom");
      this.twilioRoom.disconnect();
    }
  },
  methods: {
    /**
     * Handles to current tracks. 
     * Listens to for future tracks (publish or unpublish)
     */
    listenToRemoteParticipant (participant) {
      // handle current tracks
      console.log("listenToRemoteParticipant(), participant =", participant);
      participant.tracks.forEach(publication => {
        if (publication.isSubscribed) {
          this.mountToDOM({ div: "remote-media-div", track });
        }
      });
      this.handleFutureTracks(participant);
    },
    /**
     * Twilio => client
     * 
     * Given a remote participant, react to any of his/her published/unpublished tracks.
     * 
     * Note Twilio-Video's APIs are designed to be first person. Therefore, `remoteTrack` refers to a track from someone else.
     * 
     * @param remoteParticipant
     * 
     */
    handleFutureTracks (remoteParticipant) {
      // if someone else adds a stream
      remoteParticipant.on("trackSubscribed", remoteTrack => {
        console.log("I received a track from remoteParticipant", remoteParticipant.identity);
        this.mountToDOM({ div: "remote-media-div", track: remoteTrack })
      });

      // if someone else removes their stream
      remoteParticipant.on("trackUnsubscribed", remoteTrack => {
        console.log("Someone else turned off their stream");
        remoteTrack.detach().forEach(element => element.remove());
      });
    },
    /**
     * Given a stream of data e.g. audio, video or screenshare, make it 
     * "observable" to the user. 
     * 
     * track.attach() = 
     *   <audio autoplay></audio>
     *   <video autoplay playsinline></video>
     *   ...etc.
     * 
     * TODO: modify CSS depending on whether the stream is an audio, video or screenshare
     * 
     */
    mountToDOM ({ div, track }) {
      console.log("track.attach() =", track.attach());
      document.getElementById(div).appendChild(track.attach());
    },
    // TODO: move it to sidedrawer
    async shareScreen () {
      const stream = await navigator.mediaDevices.getDisplayMedia();
      const screenTrack = new LocalVideoTrack(stream.getTracks()[0]);
      this.twilioRoom.localParticipant.publishTrack(screenTrack);
    },
    /**
     * Creates an "access token" that is required to join a Twilio room.
     * 
     * @see https://www.twilio.com/docs/video/tutorials/user-identity-access-tokens
     */
    getAccessToken () {
      const AccessToken = require('twilio').jwt.AccessToken;
      const VideoGrant = AccessToken.VideoGrant;
      const token = new AccessToken(
        twilioCreds.ACCOUNT_SID,
        twilioCreds.API_KEY_SID,
        twilioCreds.API_KEY_SECRET
      );
      token.identity = this.user.uid;

      // Create a Video grant which enables a client to use Video 
      const videoGrant = new VideoGrant();
      token.addGrant(videoGrant);

      // Serialize the token to a JWT string
      return token.toJwt();
    },
    /**
     * TODO: not sure if necessary
     * 
     * Publish a local track i.e. client => Twilio
     *   e.g. screenshare, 
     */
    async publishTrackToTwilioRoom (localTrack) {
      await this.twilioRoom.publishTrack(localTrack);
      console.log("successfully published local track");
    },
  }
}
</script>

<style scoped>
.screen-share-container{
	/* height: 300px; */
}
.video-display{
	bottom: 0%;
	opacity: 1;
	z-index: 1000;
	padding: 0;
	margin: 0;
}
.video-row{
	padding: 0;
	margin: auto;
	margin-left: 35px;
	max-width: 1224px;
	left: 0%;
}
.video-chat-container .video-row{
	background: rgba(255,255,255,0.5);
	box-shadow: 0 0 10px;
	border-radius: 10px;
	padding: 2px;
	margin: auto;
}
@media (max-width: 600px) {
	.video-row {
		max-width: 248px;
	}
}
@media (max-width: 850px) and (min-width: 601px) {
	.video-row {
		max-width: 492px;
	}
}
@media (max-width: 1100px) and (min-width: 851px) {
	.video-row {
		max-width: 736px;
	}
}
@media (max-width: 1350px) and (min-width: 1101px) {
	.video-row {
		max-width: 980px;
	}
}

.video-col{
	padding: 2px;
}
.video-chat-container .video-col{
	margin: auto;
}

.video-container-wrapper{
	height: 135px;
	width: 240px;
	position: relative;
	border-style: solid;
	border-color: var(--v-accent-base);
	background-color: #333;
	border-radius: 10px;
}
.video-container-wrapper .video-container{
	bottom: 0; 
	position: absolute; 
	width:100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
}
.video-container-wrapper .display-bar{
	position: absolute;
	bottom: 0px;
	left: 0px;
	height: 20%;
	width: 100%;
}
.display-bar .name-container{
	background-color: rgb(31, 31, 31);
	color: white; 
	position:absolute; 
	bottom: 0px; 
	font-size: 12px;
	text-align: center;
	padding-left: 5px;
	padding-right: 5px;
	left: 0px;
	border-bottom-left-radius: 6px;
}
.display-bar .local-buttons-container{
	position: absolute;
	right: 0px;
}
.display-bar .participant-mic{
	position: absolute;
	right: 0px;
	color: white; 
	bottom: 0px;
}
.mini-view-container{
	height: 30px;
	width: 240px;
	position: relative;
	border-style: solid;
	border-color: var(--v-accent-base);
	background-color:black;
	border-radius: 10px;
}
</style>

<style>
.video-chat-container  .VueCarousel-navigation-button {
	color: rgba(255,255,255,0.7) !important;
}
.video-chat-container  .VueCarousel-navigation-button {
	color: white !important;
	text-shadow: 0 0 10px;
}
</style>
<template>
  <div>
    <template v-if="!twilioRoom">
      <h2>Connecting to Twilio...</h2>
    </template>
    <template v-else>
      <h2>Connected to Twilio!</h2>

      <BaseIconButton v-if="isMicEnabled"
      @click="toggleIsMicEnabled()"
      icon="mdi-microphone"
      color="black"
      >
        Mute microphone
      </BaseIconButton>
      <BaseIconButton v-else
      @click="toggleIsMicEnabled()"
      icon="mdi-microphone-off"
      color="red" 
      >
      <!-- TODO: Make this color prettier -->
        Unmute microphone
      </BaseIconButton>
      
      <h3 v-if="dominantParticipantUid">
        Dominant speaker: {{roomParticipantData.get(dominantParticipantUid).firstName}}
      </h3>
      
      <template v-for="[uid, micStatus] in Object.entries(participantAudioStatus)">
        <div :key="uid">
        <p>participantName: {{roomParticipantData.get(uid).firstName}}</p>
        <p>micStatus: {{micStatus}}</p>
        </div>
      </template>

      <!--<template v-for="trackObject in twilioRoom.localParticipant.tracks.values()">
        <div :key="trackObject.id">
          <p>trackName: {{ trackObject.trackName }}</p>
          <p>type of data: {{ trackObject.kind }}</p>
          <p>isEnabled: {{ trackObject.track.isEnabled }}</p>
          <p>isStarted: {{ trackObject.track.isStarted }}</p>
          <p>isStopped: {{ trackObject.track.isStopped }}</p>
        </div>
      </template>-->
      <!--<h2>Other people</h2>
      <template v-for="participant in twilioRoom.participants.values()">
        <div :key="participant.identity">
          <p>his/her ID: {{ participant.identity }}</p>
          <p>his/her connection state: {{ participant.state }}</p>
          <p>HIS/HER PUBLISHED TRACKS</p>
          <template v-for="(track, i) in participant.tracks.values()">
            <div :key="i">
              <p>type of data: {{ track.kind }}</p>
              <p>I'm subscribed: {{ track.isSubscribed }}</p>
            </div>
          </template> 
        </div>
      </template>-->
    </template>
    <!-- <v-btn @click="shareScreen()">Share screen</v-btn>    -->

    <div id="remote-audio-div">
    </div>

    <!-- Helps user fix audio issues if an error shows up -->
    <v-dialog persistent max-width="600px" v-model="isShowingErrorPopup"> 
      <v-card>
        <v-card-title>
          Couldn't connect to audio 
        </v-card-title>
        <v-card-text>
          <h3>Why audio isn't working</h3>
          <p>{{ whyItFailed }}</p>
          <h3>How to fix it</h3>
          <p>{{ howToFix }}</p>
        </v-card-text>
        <v-card-actions>
          <v-spacer/>
          <v-btn @click="isShowingErrorPopup = false" text color="secondary">
            GOT IT
          </v-btn>
        </v-card-actions>
      </v-card> 
    </v-dialog> 
  </div>
</template>

<script>
/**
 * TODO: when a stream is turned off e.g. stopped screensharing, other people don't realize. 
 * TODO: If user is on the wrong browser, display an error message to inform them to switch
 * 
 * @see screencapture https://www.twilio.com/docs/video/screen-capture-chrome
 * @see https://www.twilio.com/docs/video
 * @see API https://www.twilio.com/docs/video/tutorials/understanding-video-rooms-apis
 * @see BestPractices https://www.twilio.com/docs/video/build-js-video-application-recommendations-and-best-practices
 * 
 * A Track is a stream of bytes that contain the data generated by a multimedia source such as a microphone or a camera.
 * 
 * Correctness proof: 
 * 
 * Initial state: 
 *    - Local user publishes his/her tracks.
 *    - Local user fetches other people's tracks. 
 *    - Therefore initial state is correct. 
 * 
 * Transition state: 
 *    - every new user will be detected with "onConnected"
 *    - for each new user, each of their tracks will be handled when they are published/unpublished 
 *    - every user who disconnect will be handled by "onDisconnected"
 *    
 * Therefore, all states will be correct. 
 */
import { Carousel, Slide } from 'vue-carousel';
import Twilio from "twilio-video";
import { twilioCreds } from "@/twiliocreds.js";
import { mapState } from "vuex";
import BaseIconButton from "@/components/BaseIconButton.vue";
import Vue from "vue";

export default {
  props: {
    roomID: {
      type: String,
      required: true
    },
    roomParticipantData: {
      type: Map, // Maps uid to userData
      required: true
    }
  },
  components: {
    Carousel,
    Slide,
    BaseIconButton
  },
  data () {
    return {
      isShowingErrorPopup: false,
      whyItFailed: "",
      howToFix: "",
      isLocalAudioTrackCreated: false,
      isMicEnabled: true,
      
      // Contains connected participants with a published audio stream
      // Maps uid to the remote participants isMicEnabled value
      participantAudioStatus: {},
      
      // The remote participant with the loudest audioTrack
      dominantParticipantUid: null
    };
  },
  computed: {
    ...mapState([
      "twilioRoom",
      "user",
      "session",
    ])
  },
  created () {
    this.connectToTwilioRoom();
  },
  destroyed () {
    if (this.twilioRoom) {
      this.twilioRoom.disconnect();
      window.removeEventListener("beforeunload", this.twilioRoom.disconnect);
      window.removeEventListener("pagehide", this.twilioRoom.disconnect);
    }
  },
  watch: {
    isMicEnabled: {
      handler: 'isMicEnabledHandler'
    }
  },
  methods: {
    async connectToTwilioRoom () {
      if (!Twilio.isSupported) {
        this.isShowingErrorPopup = true; 
        this.whyItFailed = "Your browser/device combination does not support audio/video/screensharing."; 
        this.howToFix = `
          For iPads, use iOS Safari. 
          For MacBooks, use MacOS Chrome, Firefox or Safari. 
          For Windows, use Chrome or Firefox. 
          For Linux, use Chrome or Firefox. 
        `;
        return;
      }
      
      // You can succesfully connect only if you give mic permissions
      try {
        const twilioRoom = await Twilio.connect(this.getAccessToken(), { 
          name: this.roomID,
          audio: true,
          dominantSpeaker: true
        }); // video: { width: 640 }
        this.$store.commit("SET_TWILIO_ROOM", twilioRoom);
      } catch (error) {
        this.tellUserHowToFixError(error);
        return;
      }
      
      // Report succesful connection
      console.log("Joined Twilio room =", this.twilioRoom);
      console.log("localParticipant identity: ", this.twilioRoom.localParticipant.identity);
      this.$root.$emit("show-snackbar", "Connected to the voice chat.");
  
      // handle disconnections so other participants get notified immediately 
      window.addEventListener("beforeunload", this.twilioRoom.disconnect);
      window.addEventListener("pagehide", this.twilioRoom.disconnect);
            
      // handle existing participants
      this.twilioRoom.participants.forEach(
        participant => this.participantOnConnect(participant)
      );
      // handle future participant connecting
      this.twilioRoom.on("participantConnected", 
        participant => this.participantOnConnect(participant)
      );
      
      // handle future participants disconnecting
      this.twilioRoom.on("participantDisconnected", participant => {
        this.participantOnDisconnect(participant);
        this.$root.$emit("show-snackbar", "Someone disconnected."); // TODO: Remove
      });
      
      // handle dominant speaker changing
      this.twilioRoom.on('dominantSpeakerChanged',
        participant => this.onDominantSpeakerChanged(participant)
      );
    },
    toggleIsMicEnabled () {
      this.isMicEnabled = !this.isMicEnabled;
    },
    // Updates localParticipant audioTracks based on passed in val
    isMicEnabledHandler (val) {
      if (!this.twilioRoom) return;
      if (val) {
        this.twilioRoom.localParticipant.audioTracks.forEach(
          publication => publication.track.enable()
        );
      } else {
        this.twilioRoom.localParticipant.audioTracks.forEach(
          publication => publication.track.disable()
        );
      }
    },
    participantOnConnect (participant) {
      console.log("Participant onConnect", participant.identity);
      
      const tryHandleAudioTrack = (track) => {
        if (track.kind != "audio") return;
        const audioTrack = track;
        console.log("Handling audioTrack: ", audioTrack.name);
        
        const setStatus = () => Vue.set(
          this.participantAudioStatus,
          participant.identity,
          audioTrack.isEnabled
        );
        setStatus();
        audioTrack.on('disabled', setStatus);
        audioTrack.on('enabled', setStatus);
        
        this.mountAudioTrack(audioTrack);
      };
      
      const handleTrack = (track) => {
        tryHandleAudioTrack(track);
        // TODO: Add tryHandleVideoTrack
      }
      
      const handlePublication = (publication) => {
        console.log("Handling publication...");
        if (publication.isSubscribed) {
          handleTrack(publication.track);
        }
        publication.on('subscribed', handleTrack);
      }
      
      participant.tracks.forEach(handlePublication);
      participant.on("trackSubscribed", handleTrack);
    },
    participantOnDisconnect(participant) {
      console.log("Participant onDisconnect", participant.identity);
      Vue.delete(this.participantAudioStatus, participant.identity);
      this.unmountParticipantTracks(participant);
    },
    onDominantSpeakerChanged(participant) {
      this.dominantParticipantUid = participant.identity;
    },
    /**
     * The functions below takes in a track (audio or video)
     * and makes it observable or not observable to the user.
     * 
     * track.attach() = 
     *   <audio autoplay></audio>
     *   <video autoplay playsinline></video>
     *   ...etc.
     * 
     * TODO: Add support for mounting video tracks
     */
    mountAudioTrack (audioTrack) {
      console.assert(audioTrack.kind == "audio");
      document.getElementById(
        "remote-audio-div"
      ).appendChild(audioTrack.attach());
    },
    unmountTrack (track) {
      const htmlElements = track.detach();
      for (const e of htmlElements) {
        e.remove();
      }
    },
    unmountParticipantTracks (participant) {
      // Unmounts published tracks by the participant
      // should be called when the participant disconnects
      for (const publication in participant.tracks) {
        this.unmountTrack(participant);
      }
    },
    /*async shareScreen () {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia();
        const screenTrack = new Twilio.LocalVideoTrack(stream.getTracks()[0]);
        this.twilioRoom.localParticipant.publishTrack(screenTrack);
      } catch (error) {
        this.tellUserHowToFixError(error);
      }
    },*/
    /**
     * Creates an "access token" that is required to join a Twilio room.
     * 
     * @see https://www.twilio.com/docs/video/tutorials/user-identity-access-tokens
     */
    getAccessToken () {
      const AccessToken = require('twilio').jwt.AccessToken;
      const VideoGrant = AccessToken.VideoGrant;
      const token = new AccessToken(
        twilioCreds.ACCOUNT_SID,
        twilioCreds.API_KEY_SID,
        twilioCreds.API_KEY_SECRET
      );
      // TODO: want unique identifiers for each device
      token.identity = this.user.uid; 

      // Create a Video grant which enables a client to use Video 
      const videoGrant = new VideoGrant();
      token.addGrant(videoGrant);

      // Serialize the token to a JWT string
      return token.toJwt();
    },
    tellUserHowToFixError (error) {
      this.isShowingErrorPopup = true; 

      // give a specific, helpful error message
      if (error.name === "NotFoundError") {
        this.whyItFailed = `Your laptop or iPad's audio device is currently disabled in this browser.`;
        this.howToFix = `Enable your audio device for the browser in the system settings.`;
      } else if (error.name === "NotAllowedError") {
        this.whyItFailed = `At some point, you dismissed or denied the popup that asked for access to your microphone`
        this.howToFix = `
          Give access to your microphone by doing the following steps: 
            1. Click the small, circular "i" button near the left of "https://explain.mit.edu/...." 
            2. Find the settings somewhere for the audio microphone and switch to "allow" 
            3. Reload the entire website.
        `;
      } else {
        this.whyItFailed = `Failed to acquire audio media because: ${error.message}`;
        this.howToFix = ""; 
      }
    }
  }
}
</script>

<style scoped>
.screen-share-container{
	/* height: 300px; */
}
.video-display{
	bottom: 0%;
	opacity: 1;
	z-index: 1000;
	padding: 0;
	margin: 0;
}
.video-row{
	padding: 0;
	margin: auto;
	margin-left: 35px;
	max-width: 1224px;
	left: 0%;
}
.video-chat-container .video-row{
	background: rgba(255,255,255,0.5);
	box-shadow: 0 0 10px;
	border-radius: 10px;
	padding: 2px;
	margin: auto;
}
@media (max-width: 600px) {
	.video-row {
		max-width: 248px;
	}
}
@media (max-width: 850px) and (min-width: 601px) {
	.video-row {
		max-width: 492px;
	}
}
@media (max-width: 1100px) and (min-width: 851px) {
	.video-row {
		max-width: 736px;
	}
}
@media (max-width: 1350px) and (min-width: 1101px) {
	.video-row {
		max-width: 980px;
	}
}

.video-col{
	padding: 2px;
}
.video-chat-container .video-col{
	margin: auto;
}

.video-container-wrapper{
	height: 135px;
	width: 240px;
	position: relative;
	border-style: solid;
	border-color: var(--v-accent-base);
	background-color: #333;
	border-radius: 10px;
}
.video-container-wrapper .video-container{
	bottom: 0; 
	position: absolute; 
	width:100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
}
.video-container-wrapper .display-bar{
	position: absolute;
	bottom: 0px;
	left: 0px;
	height: 20%;
	width: 100%;
}
.display-bar .name-container{
	background-color: rgb(31, 31, 31);
	color: white; 
	position:absolute; 
	bottom: 0px; 
	font-size: 12px;
	text-align: center;
	padding-left: 5px;
	padding-right: 5px;
	left: 0px;
	border-bottom-left-radius: 6px;
}
.display-bar .local-buttons-container{
	position: absolute;
	right: 0px;
}
.display-bar .participant-mic{
	position: absolute;
	right: 0px;
	color: white; 
	bottom: 0px;
}
.mini-view-container{
	height: 30px;
	width: 240px;
	position: relative;
	border-style: solid;
	border-color: var(--v-accent-base);
	background-color:black;
	border-radius: 10px;
}
</style>

<style>
.video-chat-container  .VueCarousel-navigation-button {
	color: rgba(255,255,255,0.7) !important;
}
.video-chat-container  .VueCarousel-navigation-button {
	color: white !important;
	text-shadow: 0 0 10px;
}
</style>
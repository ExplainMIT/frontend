<template>
  <div>
    <template v-if="twilioRoom">
      <!-- <h2>Me</h2>
      <p>my ID: {{ twilioRoom.localParticipant.identity }}</p>
      <p>my connection state: {{ twilioRoom.localParticipant.state }}</p>
      <template v-for="trackObject in twilioRoom.localParticipant.tracks.values()">
        <div :key="trackObject.id"> 
          <p>type of data: {{ trackObject.kind }}</p>
          <p>isEnabled: {{ trackObject.track.isEnabled }}</p>
          <p>isStarted: {{ trackObject.track.isStarted }}</p>
          <p>isStopped: {{ trackObject.track.isStopped }}</p>
        </div>
      </template> -->
      <!-- <h2>Other people</h2>
      <template v-for="participant in twilioRoom.participants.values()">
        <div :key="participant.identity">
          <p>his/her ID: {{ participant.identity }}</p>
          <p>his/her connection state: {{ participant.state }}</p>
          <p>HIS/HER PUBLISHED TRACKS</p>
          <template v-for="(track, i) in participant.tracks.values()">
            <div :key="i">
              <p>type of data: {{ track.kind }}</p>
              <p>I'm subscribed: {{ track.isSubscribed }}</p>
            </div>
          </template> 
        </div>
      </template> -->
    </template>
    <!-- <v-btn @click="shareScreen()">Share screen</v-btn>    -->
    <div id="remote-media-div">

    </div>

    <v-dialog max-width="600px" v-model="isShowingConnectOptionsPopup">
      <v-card>
        <v-card-title>
          Connect to the voice chat?
        </v-card-title>
        <v-card-actions>
          <v-spacer/>
          <v-btn @click="connectToTwilioRoom()" text color="secondary">
            Yes
          </v-btn>
          <v-btn @click="isShowingConnectOptionsPopup = false" text color="secondary">
            No
          </v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

    <!-- Helps user fix audio issues if an error shows up -->
    <v-dialog persistent max-width="600px" v-model="isShowingErrorPopup"> 
      <v-card>
        <v-card-title>
          Couldn't connect to audio 
        </v-card-title>
        <v-card-text>
          <h3>Why audio isn't working</h3>
          <p>{{ whyItFailed }}</p>
          <h3>How to fix it</h3>
          <p>{{ howToFix }}</p>
        </v-card-text>
        <v-card-actions>
          <v-spacer/>
          <v-btn @click="isShowingErrorPopup = false" text color="secondary">
            GOT IT
          </v-btn>
        </v-card-actions>
      </v-card> 
    </v-dialog> 
  </div>
</template>

<script>
/**
 * TODO: when a stream is turned off e.g. stopped screensharing, other people don't realize. 
 * TODO: If user is on the wrong browser, display an error message to inform them to switch
 * 
 * @see screencapture https://www.twilio.com/docs/video/screen-capture-chrome
 * @see https://www.twilio.com/docs/video
 * @see API https://www.twilio.com/docs/video/tutorials/understanding-video-rooms-apis
 * @see BestPractices https://www.twilio.com/docs/video/build-js-video-application-recommendations-and-best-practices
 * 
 * A Track is a stream of bytes that contain the data generated by a multimedia source such as a microphone or a camera.
 * 
 * Correctness proof: 
 * 
 * Initial state: 
 *    - Local user publishes his/her tracks. 
 *    - Local user fetches other people's tracks. 
 *    - Therefore initial state is correct. 
 * 
 * Transition state: 
 *    - every new user will be detected with "onConnected"
 *    - for each new user, each of their tracks will be handled when they are published/unpublished 
 *    - every user who disconnect will be handled by "onDisconnected"
 *    
 * Therefore, all states will be correct. 
 */
import { Carousel, Slide } from 'vue-carousel';
import Twilio, { connect, LocalVideoTrack, createLocalTracks } from "twilio-video";
import { twilioCreds } from "@/twiliocreds.js";
import { mapState } from "vuex";
import { getRandomId } from "@/helpers.js";

export default {
  props: {
    roomID: {
      type: String,
      required: true
    }
  },
  components: {
    Carousel,
    Slide
  },
  data () {
    return {
      isShowingErrorPopup: false,
      isShowingConnectOptionsPopup: true,
      whyItFailed: "",
      howToFix: ""
    };
  },
  computed: {
    ...mapState([
      "twilioRoom",
      "user",
      "session",
    ])
  },
  async created () {
    // nothing for now
  },
  destroyed () {
    if (this.twilioRoom) {
      this.twilioRoom.disconnect();
      window.removeEventListener("beforeunload", this.twilioRoom.disconnect);
      window.removeEventListener("pagehide", this.twilioRoom.disconnect);
    }
  },
  methods: {
    async connectToTwilioRoom () {
      this.isShowingConnectOptionsPopup = false; 
      // check browser support
      if (!Twilio.isSupported) {
        this.isShowingErrorPopup = true; 
        this.whyItFailed = "Your browser/device combination does not support audio/video/screensharing."; 
        this.howToFix = `
          For iPads, use iOS Safari. 
          For MacBooks, use MacOS Chrome, Firefox or Safari. 
          For Windows, use Chrome or Firefox. 
          For Linux, use Chrome or Firefox. 
        `;
      }
      // TODO: handle the autoplay issue
      try {
        const twilioRoom = await Twilio.connect(this.getAccessToken(), { 
          name: this.roomID, 
          audio: true
        }); // video: { width: 640 }
        this.$store.commit("SET_TWILIO_ROOM", twilioRoom);
        console.log("Joined Twilio room =", this.twilioRoom);
        this.$root.$emit("show-snackbar", "Connected to the voice chat.");
      } catch (error) {
        this.tellUserHowToFixError(error);
        return;
      }

      // handle disconnections so other participants get notified immediately 
      window.addEventListener("beforeunload", this.twilioRoom.disconnect);
      window.addEventListener("pagehide", this.twilioRoom.disconnect);

      this.shareAudio();
      // mute ourselves to prevent feedback echoes
      this.twilioRoom.localParticipant.audioTracks.forEach(publication => {
        publication.track.disable();
      });
      
      // handle existing participants
      this.twilioRoom.participants.forEach(participant => {
        this.listenToRemoteParticipant(participant);
      });

      // handle future participants
      this.twilioRoom.on("participantConnected", participant => {
        this.listenToRemoteParticipant(participant)
      });
      
      // whenever people disconnect, remove their streams
      this.twilioRoom.on('participantDisconnected', participant => {
        this.$root.$emit("show-snackbar", "Someone disconnected."); 
      });
    },
    /**
     * Handles to current tracks. 
     * Listens to for future tracks (publish or unpublish)
     */
    listenToRemoteParticipant (participant) {
      // handle current tracks
      participant.tracks.forEach(publication => {
        if (publication.isSubscribed) {
          console.log("received a track from remoteParticipant =", participant.identity);
          this.mountToDOM({ 
            div: "remote-media-div", 
            track: publication.track 
          });
        }
      });
      this.handleFutureTracks(participant);
    },
    /**
     * Twilio => client
     * 
     * Given a remote participant, react to any of his/her published/unpublished tracks.
     * 
     * Note Twilio-Video's APIs are designed to be first person. Therefore, `remoteTrack` refers to a track from someone else.
     * 
     * @param remoteParticipant
     * 
     */
    handleFutureTracks (remoteParticipant) {
      // if someone else adds a stream, you receive it
      remoteParticipant.on("trackSubscribed", remoteTrack => {
        this.mountToDOM({ div: "remote-media-div", track: remoteTrack })
      });

      // if someone else removes their stream, you receive it
      remoteParticipant.on("trackUnsubscribed", remoteTrack => {
        remoteTrack.detach().forEach(element => element.remove());
      });
    },
    /**
     * Given a stream of data e.g. audio, video or screenshare, make it 
     * "observable" to the user. 
     * 
     * track.attach() = 
     *   <audio autoplay></audio>
     *   <video autoplay playsinline></video>
     *   ...etc.
     * 
     * TODO: modify CSS depending on whether the stream is an audio, video or screenshare
     * 
     */
    mountToDOM ({ div, track }) {
      document.getElementById(div).appendChild(track.attach());
    },
    async shareAudio () {
      const { createLocalAudioTrack } = require('twilio-video');
      createLocalAudioTrack().catch(error => this.tellUserHowToFixError(error));
      const localAudioTrack = await createLocalAudioTrack({ name: `${this.user.firstName}'s audio stream` });
      this.twilioRoom.localParticipant.publishTrack(localAudioTrack);
    },
    // TODO: move it to sidedrawer
    async shareScreen () {
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia();
        const screenTrack = new LocalVideoTrack(stream.getTracks()[0]);
        this.twilioRoom.localParticipant.publishTrack(screenTrack);
      } catch (error) {
        this.tellUserHowToFixError(error);
      }
    },
    /**
     * Creates an "access token" that is required to join a Twilio room.
     * 
     * @see https://www.twilio.com/docs/video/tutorials/user-identity-access-tokens
     */
    getAccessToken () {
      const AccessToken = require('twilio').jwt.AccessToken;
      const VideoGrant = AccessToken.VideoGrant;
      const token = new AccessToken(
        twilioCreds.ACCOUNT_SID,
        twilioCreds.API_KEY_SID,
        twilioCreds.API_KEY_SECRET
      );
      // TODO: want unique identifiers for each device
      token.identity = this.user.uid; 

      // Create a Video grant which enables a client to use Video 
      const videoGrant = new VideoGrant();
      token.addGrant(videoGrant);

      // Serialize the token to a JWT string
      return token.toJwt();
    },
    /**
     * TODO: not sure if necessary
     * 
     * Publish a local track i.e. client => Twilio
     *   e.g. screenshare, 
     */
    async publishTrackToTwilioRoom (localTrack) {
      await this.twilioRoom.publishTrack(localTrack);
      console.log("successfully published local track");
    },
    tellUserHowToFixError (error) {
      this.isShowingErrorPopup = true; 

      // give a specific, helpful error message
      if (error.name === "NotFoundError") {
        this.whyItFailed = `Your laptop or iPad's audio device is currently disabled in this browser.`;
        this.howToFix = `Enable your audio device for the browser in the system settings.`;
      } else if (error.name === "NotAllowedError") {
        this.whyItFailed = `At some point, you dismissed or denied the popup that asked for access to your microphone`
        this.howToFix = `
          Give access to your microphone by doing the following steps: 
            1. Click the small, circular "i" button near the left of "https://explain.mit.edu/...." 
            2. Find the settings somewhere for the audio microphone and switch to "allow" 
            3. Reload the entire website. 
        `;
      } else {
        this.whyItFailed = `Failed to acquire audio media because: ${error.message}`;
        this.howToFix = ""; 
      }
    }
  }
}
</script>

<style scoped>
.screen-share-container{
	/* height: 300px; */
}
.video-display{
	bottom: 0%;
	opacity: 1;
	z-index: 1000;
	padding: 0;
	margin: 0;
}
.video-row{
	padding: 0;
	margin: auto;
	margin-left: 35px;
	max-width: 1224px;
	left: 0%;
}
.video-chat-container .video-row{
	background: rgba(255,255,255,0.5);
	box-shadow: 0 0 10px;
	border-radius: 10px;
	padding: 2px;
	margin: auto;
}
@media (max-width: 600px) {
	.video-row {
		max-width: 248px;
	}
}
@media (max-width: 850px) and (min-width: 601px) {
	.video-row {
		max-width: 492px;
	}
}
@media (max-width: 1100px) and (min-width: 851px) {
	.video-row {
		max-width: 736px;
	}
}
@media (max-width: 1350px) and (min-width: 1101px) {
	.video-row {
		max-width: 980px;
	}
}

.video-col{
	padding: 2px;
}
.video-chat-container .video-col{
	margin: auto;
}

.video-container-wrapper{
	height: 135px;
	width: 240px;
	position: relative;
	border-style: solid;
	border-color: var(--v-accent-base);
	background-color: #333;
	border-radius: 10px;
}
.video-container-wrapper .video-container{
	bottom: 0; 
	position: absolute; 
	width:100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
}
.video-container-wrapper .display-bar{
	position: absolute;
	bottom: 0px;
	left: 0px;
	height: 20%;
	width: 100%;
}
.display-bar .name-container{
	background-color: rgb(31, 31, 31);
	color: white; 
	position:absolute; 
	bottom: 0px; 
	font-size: 12px;
	text-align: center;
	padding-left: 5px;
	padding-right: 5px;
	left: 0px;
	border-bottom-left-radius: 6px;
}
.display-bar .local-buttons-container{
	position: absolute;
	right: 0px;
}
.display-bar .participant-mic{
	position: absolute;
	right: 0px;
	color: white; 
	bottom: 0px;
}
.mini-view-container{
	height: 30px;
	width: 240px;
	position: relative;
	border-style: solid;
	border-color: var(--v-accent-base);
	background-color:black;
	border-radius: 10px;
}
</style>

<style>
.video-chat-container  .VueCarousel-navigation-button {
	color: rgba(255,255,255,0.7) !important;
}
.video-chat-container  .VueCarousel-navigation-button {
	color: white !important;
	text-shadow: 0 0 10px;
}
</style>